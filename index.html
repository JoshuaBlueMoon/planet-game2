<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Planet Explorer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Add starry skybox
        const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide }),
            new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide })
        ];
        for (let i = 0; i < 6; i++) {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let j = 0; j < 1000; j++) {
                starVertices.push((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);

        // Add PointerLockControls for first-person movement
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());
        scene.add(controls.getObject());

        // Planet parameters (perfect cube)
        const planetSize = { x: 16, y: 16, z: 16 }; // Perfect cube: 16x16x16
        const blockSize = 1;
        const blocks = [];

        // Generate the cuboid planet (solid cube)
        function generatePlanet() {
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, 
                roughness: 0.7, 
                metalness: 0.1 
            });

            for (let x = 0; x < planetSize.x; x++) {
                for (let y = 0; y < planetSize.y; y++) {
                    for (let z = 0; z < planetSize.z; z++) {
                        const block = new THREE.Mesh(geometry, material);
                        block.position.set(
                            (x - planetSize.x / 2) * blockSize,
                            (y - planetSize.y / 2) * blockSize,
                            (z - planetSize.z / 2) * blockSize
                        );
                        block.castShadow = true;
                        block.receiveShadow = true;
                        scene.add(block);
                        blocks.push(block);
                    }
                }
            }
            console.log(`Generated ${blocks.length} blocks for planet (should be ${planetSize.x * planetSize.y * planetSize.z})`);
        }

        // Function to create atmosphere layer
        function createAtmosphereLayer(size, color, baseOpacity) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(color) },
                    cameraPos: { value: camera.position },
                    baseOpacity: { value: baseOpacity },
                    planetCenter: { value: new THREE.Vector3(0, 0, 0) },
                    planetSize: { value: size }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform vec3 cameraPos;
                    uniform float baseOpacity;
                    uniform vec3 planetCenter;
                    uniform float planetSize;
                    varying vec3 vWorldPosition;
                    void main() {
                        float distToCenter = length(vWorldPosition - planetCenter);
                        float maxDist = planetSize * 0.5;
                        float opacity = baseOpacity * (1.0 - clamp(distToCenter / maxDist, 0.0, 1.0));
                        float viewFactor = clamp(length(cameraPos - planetCenter) / (maxDist * 1.5), 0.5, 1.0);
                        opacity *= viewFactor;
                        opacity = clamp(opacity, baseOpacity * 0.3, baseOpacity * 0.8);
                        gl_FragColor = vec4(color, opacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                lights: false
            });
            const atmosphere = new THREE.Mesh(geometry, material);
            atmosphere.position.set(0, 0, 0);
            scene.add(atmosphere);
            return { material, size };
        }

        // Create three atmosphere layers
        const atmosphereLayers = [];
        atmosphereLayers.push(createAtmosphereLayer(planetSize.x + 2, 0x00ccff, 0.6));
        atmosphereLayers.push(createAtmosphereLayer(planetSize.x + 3, 0x66ccff, 0.4));
        atmosphereLayers.push(createAtmosphereLayer(planetSize.x + 4, 0x99ccff, 0.2));

        // Add fog for immersive effect
        const fog = new THREE.Fog(0x00ccff, 5, 15);
        scene.fog = null;

        function updateFog() {
            const cameraPos = camera.position;
            const planetCenter = new THREE.Vector3(0, 0, 0);
            const distToCenter = cameraPos.distanceTo(planetCenter);
            let insideAtmosphere = false;
            let fogColor = 0x00ccff;
            let fogDensity = 0;

            for (let i = 0; i < atmosphereLayers.length; i++) {
                const layerSize = atmosphereLayers[i].size;
                const halfSize = layerSize / 2;
                if (distToCenter < halfSize) {
                    insideAtmosphere = true;
                    fogColor = atmosphereLayers[i].material.uniforms.color.value.getHex();
                    fogDensity = 0.05 * (1 - i / atmosphereLayers.length);
                    break;
                }
            }

            if (insideAtmosphere) {
                scene.fog = new THREE.Fog(fogColor, 5, 15 * (1 + fogDensity));
            } else {
                scene.fog = null;
            }
        }

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(20, 20, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 512;
        sunLight.shadow.mapSize.height = 512;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        sunLight.shadow.camera.left = -20;
        sunLight.shadow.camera.right = 20;
        sunLight.shadow.camera.top = 20;
        sunLight.shadow.camera.bottom = -20;
        scene.add(sunLight);
        const secondaryLight = new THREE.DirectionalLight(0x80d4ff, 0.2);
        secondaryLight.position.set(-10, 10, -10);
        scene.add(secondaryLight);

        // Set initial camera position (above planet surface)
        camera.position.set(0, planetSize.y / 2 + 1.8, 0);
        camera.lookAt(0, planetSize.y / 2, -1);

        // Handle block breaking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        document.addEventListener('mousedown', (event) => {
            if (!controls.isLocked) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);
            if (intersects.length > 0) {
                const block = intersects[0].object;
                scene.remove(block);
                blocks.splice(blocks.indexOf(block), 1);
            }
        });

        // Physics and movement variables
        const moveSpeed = 0.1;
        const gravity = 0.02;
        const jumpSpeed = 0.3;
        const velocity = new THREE.Vector3();
        const clock = new THREE.Clock();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let isFlying = true; // Default to flying mode
        let isOnGround = false;
        const playerHeight = 1.8; // Player height
        const playerRadius = 0.3; // Player width/depth for AABB

        // Toggle flight mode with 'G' key
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (isFlying) moveUp = true;
                    else if (isOnGround) velocity.y = jumpSpeed;
                    break;
                case 'ShiftLeft': if (isFlying) moveDown = true; break;
                case 'KeyG': 
                    isFlying = !isFlying;
                    if (!isFlying) velocity.y = 0;
                    console.log('Flight mode:', isFlying ? 'Enabled' : 'Disabled');
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': moveUp = false; break;
                case 'ShiftLeft': moveDown = false; break;
            }
        });

        // AABB collision detection
// Improved AABB collision: resolve axis by axis for smooth sliding
function checkCollisions(position, velocity, delta) {
    let newPosition = position.clone();
    let newVelocity = velocity.clone();
    isOnGround = false;
    const halfSize = blockSize / 2;

    // Helper for player's AABB
    function getPlayerBox(pos) {
        return {
            min: new THREE.Vector3(pos.x - playerRadius, pos.y - playerHeight, pos.z - playerRadius),
            max: new THREE.Vector3(pos.x + playerRadius, pos.y, pos.z + playerRadius),
        };
    }

    // X axis
    if (newVelocity.x !== 0) {
        let tryPos = newPosition.clone();
        tryPos.x += newVelocity.x * delta * 60;
        let playerBox = getPlayerBox(tryPos);
        let collided = false;
        for (const block of blocks) {
            const blockPos = block.position;
            const blockBox = {
                min: new THREE.Vector3(blockPos.x - halfSize, blockPos.y - halfSize, blockPos.z - halfSize),
                max: new THREE.Vector3(blockPos.x + halfSize, blockPos.y + halfSize, blockPos.z + halfSize)
            };
            if (
                playerBox.min.x < blockBox.max.x && playerBox.max.x > blockBox.min.x &&
                playerBox.min.y < blockBox.max.y && playerBox.max.y > blockBox.min.y &&
                playerBox.min.z < blockBox.max.z && playerBox.max.z > blockBox.min.z
            ) {
                collided = true;
                break;
            }
        }
        if (!collided) {
            newPosition.x = tryPos.x;
        } else {
            newVelocity.x = 0;
        }
    }

    // Y axis
    if (newVelocity.y !== 0) {
        let tryPos = newPosition.clone();
        tryPos.y += newVelocity.y * delta * 60;
        let playerBox = getPlayerBox(tryPos);
        let collided = false;
        for (const block of blocks) {
            const blockPos = block.position;
            const blockBox = {
                min: new THREE.Vector3(blockPos.x - halfSize, blockPos.y - halfSize, blockPos.z - halfSize),
                max: new THREE.Vector3(blockPos.x + halfSize, blockPos.y + halfSize, blockPos.z + halfSize)
            };
            if (
                playerBox.min.x < blockBox.max.x && playerBox.max.x > blockBox.min.x &&
                playerBox.min.y < blockBox.max.y && playerBox.max.y > blockBox.min.y &&
                playerBox.min.z < blockBox.max.z && playerBox.max.z > blockBox.min.z
            ) {
                collided = true;
                if (newVelocity.y > 0) {
                    // Hit ceiling
                    newPosition.y = blockBox.min.y - 0.01;
                } else {
                    // Hit ground
                    newPosition.y = blockBox.max.y + playerHeight + 0.01;
                    isOnGround = true;
                }
                newVelocity.y = 0;
                break;
            }
        }
        if (!collided) {
            newPosition.y = tryPos.y;
        }
    }

    // Z axis
    if (newVelocity.z !== 0) {
        let tryPos = newPosition.clone();
        tryPos.z += newVelocity.z * delta * 60;
        let playerBox = getPlayerBox(tryPos);
        let collided = false;
        for (const block of blocks) {
            const blockPos = block.position;
            const blockBox = {
                min: new THREE.Vector3(blockPos.x - halfSize, blockPos.y - halfSize, blockPos.z - halfSize),
                max: new THREE.Vector3(blockPos.x + halfSize, blockPos.y + halfSize, blockPos.z + halfSize)
            };
            if (
                playerBox.min.x < blockBox.max.x && playerBox.max.x > blockBox.min.x &&
                playerBox.min.y < blockBox.max.y && playerBox.max.y > blockBox.min.y &&
                playerBox.min.z < blockBox.max.z && playerBox.max.z > blockBox.min.z
            ) {
                collided = true;
                break;
            }
        }
        if (!collided) {
            newPosition.z = tryPos.z;
        } else {
            newVelocity.z = 0;
        }
    }

    return { newPosition, newVelocity };
}

            let newPosition = position.clone();
            let newVelocity = velocity.clone();
            isOnGround = false;

            // Test collisions along each axis separately
            for (const block of blocks) {
                const blockPos = block.position;
                const blockBox = {
                    min: new THREE.Vector3(
                        blockPos.x - halfSize,
                        blockPos.y - halfSize,
                        blockPos.z - halfSize
                    ),
                    max: new THREE.Vector3(
                        blockPos.x + halfSize,
                        blockPos.y + halfSize,
                        blockPos.z + halfSize
                    )
                };

                // Test Y-axis (vertical) collision
                let testPos = newPosition.clone();
                testPos.y += newVelocity.y * delta * 60;
                let testBox = {
                    min: new THREE.Vector3(playerBox.min.x, testPos.y - playerHeight, playerBox.min.z),
                    max: new THREE.Vector3(playerBox.max.x, testPos.y, playerBox.max.z)
                };

                if (
                    testBox.min.x < blockBox.max.x && testBox.max.x > blockBox.min.x &&
                    testBox.min.z < blockBox.max.z && testBox.max.z > blockBox.min.z &&
                    testBox.min.y < blockBox.max.y && testBox.max.y > blockBox.min.y
                ) {
                    if (newVelocity.y > 0) {
                        // Hit ceiling
                        newPosition.y = blockBox.min.y - 0.01;
                        newVelocity.y = 0;
                    } else if (newVelocity.y <= 0) {
                        // Hit ground
                        newPosition.y = blockBox.max.y + playerHeight + 0.01;
                        newVelocity.y = 0;
                        isOnGround = true;
                    }
                }
            }

            // Apply Y movement if no collision
            if (!isOnGround && newVelocity.y !== 0) {
                newPosition.y += newVelocity.y * delta * 60;
            }

            // Test X-axis collision
            for (const block of blocks) {
                const blockPos = block.position;
                const blockBox = {
                    min: new THREE.Vector3(blockPos.x - halfSize, blockPos.y - halfSize, blockPos.z - halfSize),
                    max: new THREE.Vector3(blockPos.x + halfSize, blockPos.y + halfSize, blockPos.z + halfSize)
                };

                let testPos = newPosition.clone();
                testPos.x += newVelocity.x * delta * 60;
                let testBox = {
                    min: new THREE.Vector3(testPos.x - playerRadius, playerBox.min.y, playerBox.min.z),
                    max: new THREE.Vector3(testPos.x + playerRadius, playerBox.max.y, playerBox.max.z)
                };

                if (
                    testBox.min.y < blockBox.max.y && testBox.max.y > blockBox.min.y &&
                    testBox.min.z < blockBox.max.z && testBox.max.z > blockBox.min.z &&
                    testBox.min.x < blockBox.max.x && testBox.max.x > blockBox.min.x
                ) {
                    newVelocity.x = 0;
                }
            }

            // Test Z-axis collision
            for (const block of blocks) {
                const blockPos = block.position;
                const blockBox = {
                    min: new THREE.Vector3(blockPos.x - halfSize, blockPos.y - halfSize, blockPos.z - halfSize),
                    max: new THREE.Vector3(blockPos.x + halfSize, blockPos.y + halfSize, blockPos.z + halfSize)
                };

                let testPos = newPosition.clone();
                testPos.z += newVelocity.z * delta * 60;
                let testBox = {
                    min: new THREE.Vector3(playerBox.min.x, playerBox.min.y, testPos.z - playerRadius),
                    max: new THREE.Vector3(playerBox.max.x, playerBox.max.y, testPos.z + playerRadius)
                };

                if (
                    testBox.min.x < blockBox.max.x && testBox.max.x > blockBox.min.x &&
                    testBox.min.y < blockBox.max.y && testBox.max.y > blockBox.min.y &&
                    testBox.min.z < blockBox.max.z && testBox.max.z > blockBox.min.z
                ) {
                    newVelocity.z = 0;
                }
            }

            return { newPosition, newVelocity };
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Apply movement
            velocity.x = 0;
            velocity.z = 0;
            if (moveForward) velocity.z -= moveSpeed;
            if (moveBackward) velocity.z += moveSpeed;
            if (moveLeft) velocity.x -= moveSpeed;
            if (moveRight) velocity.x += moveSpeed;

            if (isFlying) {
                velocity.y = 0;
                if (moveUp) velocity.y += moveSpeed;
                if (moveDown) velocity.y -= moveSpeed;
                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);
                camera.position.y += velocity.y;
            } else {
                // Apply gravity
                velocity.y -= gravity * delta * 60;

                // Check collisions and update position
                const { newPosition, newVelocity } = checkCollisions(camera.position, velocity, delta);
                camera.position.copy(newPosition);
                velocity.copy(newVelocity);

                // Apply horizontal movement via controls
                controls.moveRight(velocity.x);
                controls.moveForward(velocity.z);
            }

            // Update atmosphere and fog
            atmosphereLayers.forEach(layer => {
                layer.material.uniforms.cameraPos.value.copy(camera.position);
            });
            updateFog();

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Generate the planet and start the game
        try {
            generatePlanet();
            animate();
        } catch (error) {
            console.error('Error generating planet:', error);
        }
    </script>
</body>
</html>
